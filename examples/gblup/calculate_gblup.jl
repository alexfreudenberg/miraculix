#  Authors 
#  Alexander Freudenberg, alexander.freudenberg@stads.de

#  Copyright (C) 2023 Alexander Freudenberg

#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


using Base;
@timev "Loading libraries" begin
    using Random;
    using LinearAlgebra;
    using CSV;
    using DelimitedFiles;
    using DataFrames;
    using BenchmarkTools;
    using LoopVectorization;
    using Statistics;
end

# =====================
# Global definitions
# =====================

ROOT_DIR = string(@__DIR__) * "/../.."

MODULE_PATH = ROOT_DIR * "/src/bindings/Julia/miraculix.jl"
LIBRARY_PATH = ROOT_DIR * "/src/miraculix/miraculix.so"
DATA_DIR = ROOT_DIR * "/data"
LOG_DIR = DATA_DIR * "/logs"

# Control miraculix verbosity
ENV["PRINT_LEVEL"] = "1";

# Get thread number
@assert haskey(ENV, "OMP_NUM_THREADS") "OMP_NUM_THREADS not set"
OMP_NUM_THREADS = ENV["OMP_NUM_THREADS"];
BLAS.set_num_threads(parse(Int,OMP_NUM_THREADS))
println("OMP threads set to $OMP_NUM_THREADS")
include(MODULE_PATH)

# =====================
# Auxiliary functions
# =====================
function multiply_ld(obj_ref::Ref{Ptr{Cvoid}}, snps::Int, indiv::Int, B::Matrix{Float64})
    # Calculate SNPs times Matrix
    Z_vec = miraculix.dgemm_compressed.dgemm_compressed_main(false, obj_ref, B, snps, indiv)
    # Calculate Individuals times Matrix
    ZtZ_vec = miraculix.dgemm_compressed.dgemm_compressed_main(true, obj_ref, Z_vec, snps, indiv)
    return ZtZ_vec
end
function randomized_range_finder(obj_ref::Ref{Ptr{Cvoid}}, snps::Int, indiv::Int, l::Int, q::Int)
    # This function implements the randomized range finder from Halko et al., 2011
    ncol = snps
    Omega = randn(Float64, (ncol, l))
    Y = multiply_ld(obj_ref, snps, indiv, Omega)
    QRj = qr(Y).Q |> Matrix
    if q > 0
        for _ in range(1,q)
            ZtZ_Q = multiply_ld(obj_ref, snps, indiv, QRj)
            QRj = qr(ZtZ_Q).Q |> Matrix
            ZtZ_Q = multiply_ld(obj_ref, snps, indiv, QRj)  #G * QRj
            QRj = qr(ZtZ_Q).Q |> Matrix
        end
    end
    return QRj
end # function

function randomized_eigen(obj_ref::Ref{Ptr{Cvoid}}, snps::Int, indiv::Int, n::Int, p::Int = 40, q::Int = 2)
    # For documentation of hyperparameters, see Halko et al., 2011
    QR_rf = randomized_range_finder(obj_ref, snps, indiv, n + p, q)
    ZtZ_Q = multiply_ld(obj_ref, snps, indiv, QR_rf)
    EV = eigvecs(transpose(QR_rf) * ZtZ_Q)
    U = QR_rf * EV

    return U
end # function

function randomized_snp_pca(plink::Matrix{UInt8}, plink_transposed::Matrix{UInt8}, snps::Int, indiv::Int, n::Int, p::Int = 40)
    obj_ref = miraculix.dgemm_compressed.init_compressed(plink, plink_transposed, snps, indiv, freq, n+p)

    U = randomized_eigen(obj_ref, snps, indiv, n, p)
    PC = miraculix.dgemm_compressed.dgemm_compressed_main(false, obj_ref, U, snps, indiv)

    miraculix.dgemm_compressed.free_compressed(obj_ref)
    return PC[:,(end-n+1):end]
end

# =====================
# Main
# =====================

miraculix.set_library_path(LIBRARY_PATH)
miraculix.load_shared_library()
miraculix.dgemm_compressed.set_options(use_gpu=true, verbose=0)

# We assume that genotype data has been generated by the R package MoBPS 
data_file = DATA_DIR * "/mobps_simulation.bed"

# Read-in data from PLINK binary format
@info "Reading in data from $data_file and transpose it"
@timev "Preprocessing" begin
    # Read PLINK data and calculate allele frequencies
    wtime = @elapsed plink, freq, n_snps, n_indiv = miraculix.read_plink.read_bed(data_file, coding_twobit = true, calc_freq = true, check_for_missings = false)
    @debug "Time for reading: $wtime s."

    # Read in phenotype data
    pheno = CSV.read(DATA_DIR * "/mobps_simulation.fam", delim = ' ', DataFrame, header = 0)[:,6]
    # Read in true breeding values that were used for simulation
    bv_true = CSV.read(DATA_DIR * "/mobps_simulation.bv", delim=' ', DataFrame, header = 0)[1,:] |> Vector

    if (length(ARGS) > 0) && (ARGS[1] == "test")
        n_snps = 1000
        plink = plink[:,1:n_snps]
        freq = freq[1:n_snps]
    end
    
    # Transpose matrix
    wtime = @elapsed plink_transposed = miraculix.compressed_operations.transpose_genotype_matrix(plink, n_snps, n_indiv)
    @debug "Time for transposing: $wtime s."

    GC.gc()
end

# Calculate the GRM in miraculix
@info "Calculating the genomic relationship matrix"
@timev "GRM" begin
    G = miraculix.crossproduct.grm(plink_transposed, n_snps, n_indiv, is_plink_format = false, allele_freq = vec(freq), do_scale = true)
end


# Convert twobit encoding back to PLINK
@info "Converting matrix back to PLINK format for phenotype multiplication"
@timev "Format conversion" begin
    vmapt!(miraculix.read_plink.convert_twobit2plink, plink, plink)
    vmapt!(miraculix.read_plink.convert_twobit2plink, plink_transposed, plink_transposed)
end

# Multiply eigenvectors by SNP matrix to obtain principal components of SNPs
@info "Calculating principal components"
@timev "principal components" begin
    princ_comps = randomized_snp_pca(plink, plink_transposed, n_snps, n_indiv, 10)
    plink, plink_transposed = Nothing, Nothing
    GC.gc()
end

GC.gc()
# Calculate BLUE for beta through the formula
# \hat{beta} = (X^T (lambda I + G)^{-1} X)^{-1} X^T (lambda I + G)^{-1} Y
# with lambda = sigma_u^2 / sigma_epsilon^2 
# We assume a known heritability of 0.5 and hence lambda = 1
@info "Estimating Î² and u"
@timev "gBLUP" begin
    lambda = 1.0
    G[diagind(G)] .+= lambda
    # Design matrix of fixed effects
    X = hcat(ones(Float64, (n_indiv, 1)), princ_comps)
    Y = pheno
    rhs_matrix = hcat(X, Y)

    # Solve X B = Y
    B = miraculix.solve.dense_solve(G, rhs_matrix, calc_logdet = false, oversubscribe = false)
    # Calculate X^T (lambda I + G)^{-1} X and  X^T (lambda I + G)^{-1} Y
    Xt_B = transpose(X) * B
    
    # Get beta hat by solving X^T (lambda I + G)^{-1} X for X^T (lambda I + G)^{-1} Y
    # Since the LHS is quite small we use a standard solve
    beta_hat = Xt_B[:, 1:(end-1)] \ Xt_B[:,end]

    # Solve (G + lambda I) for (Y - X beta_hat)
    B = miraculix.solve.dense_solve(G, reshape(Y - X * beta_hat, (n_indiv, 1)), calc_logdet = false, oversubscribe = false)

    # Calculate genomic values 
    g = G * B - B
end

# Calculate correlation between estimated breeding values and true breeding values
cor_bv = cor(g, bv_true)[1]
println("Correlation between estimated breeding values and true breeding values: $(round(cor_bv, digits=3)).")

# Calculate correlation between phenotype and fitted model
fit = X * beta_hat + g
cor_fit = cor(fit, pheno)[1]
println("Correlation between phenotype and fitted model: $(round(cor_fit, digits=3)).")