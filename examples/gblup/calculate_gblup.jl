#  Authors 
#  Alexander Freudenberg, alexander.freudenberg@stads.de

#  Copyright (C) 2023 Alexander Freudenberg

#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


using Base;
using Random;
using LinearAlgebra;
using CSV;
using DelimitedFiles;
using DataFrames;
using BenchmarkTools;
using LoopVectorization;

# =====================
# Global definitions
# =====================

ROOT_DIR = string(@__DIR__) * "/../.."

MODULE_PATH = ROOT_DIR * "/src/bindings/Julia/miraculix.jl"
LIBRARY_PATH = ROOT_DIR * "/src/miraculix/miraculix.so"
DATA_DIR = ROOT_DIR * "/data"
LOG_DIR = DATA_DIR * "/logs"

# Control miraculix verbosity
ENV["PRINT_LEVEL"] = "1";

OMP_NUM_THREADS = ENV["OMP_NUM_THREADS"];
println("OMP threads set to $OMP_NUM_THREADS")

include(MODULE_PATH)

# =====================
# Auxiliary functions
# =====================
function randomized_range_finder(G::Matrix{Float64}, l::Int, q::Int)
    # This function implements the randomized range finder from Halko et al., 2011
    ncol = size(G,2)
    Omega = randn(Float64, (ncol, l))
    Y = G * Omega
    QRj = qr(Y).Q |> Matrix
    if q > 0
        for _ in range(1,q)
            Gt_Q = transpose(transpose(QRj) * G) |> Matrix
            QRj = qr(Gt_Q).Q |> Matrix
            G_Q = G * QRj
            QRj = qr(G_Q).Q |> Matrix
        end
    end
    return QRj
end # function

function randomized_eigen(G::Matrix{Float64}, n::Int, p::Int = 40, q::Int = 2)
    # For documentation of hyperparameters, see Halko et al., 2011
    QR_rf = randomized_range_finder(G, n + p, q)
    Qt_G = transpose(QR_rf) * G
    EV = eigvecs(Qt_G * QR_rf)
    U = QR_rf * EV
    return U
end # function


# =====================
# Main
# =====================

miraculix.set_library_path(LIBRARY_PATH)
miraculix.load_shared_library()

# We assume that genotype data has been generated by the R package MoBPS 
data_file = DATA_DIR * "/mobps_simulation.bed"

# Read-in data from PLINK binary format
@info "Reading in data from $data_file"
wtime = @elapsed begin
    plink, freq, n_snps, n_indiv = miraculix.read_plink.read_bed(data_file, coding_twobit = true, calc_freq = true, check_for_missings = false)
end
@info "Importing data required $(round(wtime,digits=3)) seconds."

@info "Transposing PLINK matrix."
GC.gc()
wtime = @elapsed begin
    plink_transposed = miraculix.compressed_operations.transpose_genotype_matrix(plink, n_snps, n_indiv)
end
@info "Transposing required $(round(wtime,digits=3)) seconds"


# Calculate the GRM in miraculix
@info "Calculating the genomic relationship matrix"
GC.gc()
wtime = @elapsed begin
    G = miraculix.crossproduct.grm(plink_transposed, n_snps, n_indiv, is_plink_format = false, allele_freq = vec(freq), do_scale = true)
end
@info "GRM calculation required $(round(wtime,digits=3)) seconds"

# Calculate the approximate 10 eigenvectors of G
@info "Calculating eigenvectors of G"
wtime = @elapsed begin
    eigen_G = randomized_eigen(G, 10)
end
@info "Eigenvector calculation required $(round(wtime,digits=3)) seconds"


# Convert twobit encoding back to PLINK
@info "Converting matrix back to PLINK format for phenotype multiplication"
wtime = @elapsed begin
    vmapt!(miraculix.read_plink.convert_twobit2plink, plink, plink)
    vmapt!(miraculix.read_plink.convert_twobit2plink, plink_transposed, plink_transposed)
end
@info "Format conversion required $(round(wtime,digits=3)) seconds"

# Multiply eigenvectors by SNP matrix to obtain principal components
@info "Calculating principal components"
wtime = @elapsed begin
    miraculix.dgemm_compressed.set_options(use_gpu=true, verbose=0)
    
    obj_ref = miraculix.dgemm_compressed.init_compressed(plink, plink_transposed, n_snps, n_indiv, freq, 10)
    princ_comps = miraculix.dgemm_compressed.dgemm_compressed_main(true, obj_ref, eigen_G, n_snps, n_indiv)

    miraculix.dgemm_compressed.free_compressed(obj_ref)
end

